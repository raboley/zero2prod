version: "3"

vars:
  APP_URL:
    sh: doctl apps list --format ID,Spec.Name,DefaultIngress --no-header | grep zero2prod | awk '{print $3}'
  DB_ID:
    sh: doctl databases list --format ID,Name --no-header | grep newsletter | awk '{print $1}'
  APP_ID:
    sh: doctl apps list --format ID,Spec.Name --no-header | grep zero2prod | awk '{print $1}'

tasks:
  run:
    desc: build the app and run it on port 8000
    cmds:
      - cargo run

  docker-run:
    deps:
      - docker-build
    cmds:
      - docker run -p 8000:8000 zero2prod

  docker-debug:
    deps:
      - docker-build
    cmds:
      - docker run --rm -p 8000:8000 -e RUST_LOG=debug -e DATABASE__HOST=host.docker.internal -e DATABASE__USERNAME=app -e DATABASE__PASSWORD=secret zero2prod

  docker-build:
    sources:
      - src/**/*.rs
      - src/*.rs
      - migrations
      - cargo.toml
      - Dockerfile
      - sqlx-data.json
    generates:
      - .task/docker_build.txt
    cmds:
      - docker build -t zero2prod .
      - mkdir -p .task && touch .task/docker_build.txt

  init:
    desc: Install all the rust tooling locally
    cmds:
      - rustup update
      - rustup install 1.82.0
      - rustup default 1.82.0
      - rustc --version
      - cargo --version
      - brew install lld
      - cargo install cargo-watch --version 8.5.3
      - cargo install cargo-llvm-cov --version 0.6.15
      - rustup component add clippy
      - rustup component add rustfmt
      - cargo install cargo-audit --version 0.21.1
      - rustup toolchain install nightly
      - cargo +nightly install cargo-expand --version 1.0.114
      - cargo install sqlx-cli --version 0.6.3 --no-default-features --features rustls,postgres
      - cargo install cargo-udeps --version 0.1.29
      - cargo install bunyan --version 0.1.9
      - brew install doctl

  pre-commit:
    desc: Run things that should be done pre-commiting
    deps:
      - fmt
      - tidy

  tidy:
    desc: clean up unused deps
    cmds:
      - cargo +nightly udeps --backend depinfo

  watch:
    desc: watch all files and run tests then app
    cmds:
      - cargo watch -x check -x test -x run

  test:
    desc: run tests
    cmds:
      - cargo test

  test-w-logs:
    desc: run tests with logs printing to stdout
    env:
      TEST_LOG: true
    cmds:
      - cargo test | bunyan

  fmt:
    desc: format all files
    cmds:
      - cargo fmt

  audit:
    desc: audit for things
    cmds:
      - cargo audit

  expand:
    desc: expand all the macros in our rust code
    cmds:
      - cargo +nightly expand

  db-up:
    desc: spin up the db container
    cmds:
      - ./scripts/init_db.sh

  db-migrate:
    desc: run the db migrations on the running database
    env:
      SKIP_DOCKER: true
    cmds:
      - ./scripts/init_db.sh

  db-down:
    desc: spin down the db container
    cmds:
      - docker stop postgres
      - docker rm postgres

  sqlx-prepare:
    desc: generate sqlx offline query metadata
    cmds:
      - cargo sqlx prepare --database-url postgres://app:secret@localhost:5432/newsletter --merged -- --all-targets

  deploy:
    desc: deploy app to digital ocean
    cmds:
      - |
        if doctl apps list --format Spec.Name --no-header | grep -q "^zero2prod$"; then
          APP_ID=$(doctl apps list --format ID,Spec.Name --no-header | grep zero2prod | awk '{print $1}')
          echo "App exists with ID: $APP_ID, updating..."
          doctl apps update $APP_ID --spec spec.yaml
        else
          echo "App doesn't exist, creating new deployment..."
          doctl apps create --spec spec.yaml
        fi

  health-check:
    desc: check health of deployed app
    cmds:
      - curl -f -s "{{.APP_URL}}/health_check" --verbose

  test-subscription:
    desc: test the /subscriptions endpoint with a sample subscriber
    cmds:
      - |
        curl --request POST \
          --data 'name=le%20guin&email=ursula_le_guin%40gmail.com' \
          {{.APP_URL}}/subscriptions \
          --verbose

  db-trusted-sources:
    internal: true
    vars:
      ENABLED: '{{.ENABLED | default "true"}}'
    cmds:
      - |
        if [ "{{.ENABLED}}" = "false" ]; then
          echo "Disabling trusted sources..."
          # Use API directly since doctl doesn't support empty rules
          curl -s -X PUT \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $(doctl auth token)" \
            -d '{"rules": []}' \
            "https://api.digitalocean.com/v2/databases/{{.DB_ID}}/firewall" > /dev/null
        else
          echo "Enabling trusted sources..."
          doctl databases firewalls replace {{.DB_ID}} --rule app:{{.APP_ID}} > /dev/null
        fi

  db-migrate-prod:
    desc: run database migrations on production database
    cmds:
      - |
        if [ -z "{{.DB_ID}}" ]; then
          echo "Error: No newsletter database found"
          exit 1
        fi
      - task: db-trusted-sources
        vars:
          ENABLED: "false"
      - defer:
          task: db-trusted-sources
          vars:
            ENABLED: "true"
      - |
        CONNECTION_URI=$(doctl databases connection {{.DB_ID}} --format URI --no-header)
        echo "Running migrations on $CONNECTION_URI..."
        DATABASE_URL="$CONNECTION_URI" sqlx migrate run

  destroy:
    desc: destroy the app and optionally the database
    cmds:
      - |
        echo "⚠️  WARNING: This will destroy your zero2prod app!"
        echo -n "Are you sure? (y/N): "
        read -r response
        if [ "$response" != "y" ] && [ "$response" != "Y" ]; then
          echo "Cancelled"
          exit 0
        fi
        
        # Delete the app
        if [ -n "{{.APP_ID}}" ]; then
          echo "Destroying app {{.APP_ID}}..."
          doctl apps delete {{.APP_ID}} --force
        else
          echo "No app found to delete"
        fi
        
        # Ask about database
        if [ -n "{{.DB_ID}}" ]; then
          echo -n "Also destroy the database? (y/N): "
          read -r response
          if [ "$response" = "y" ] || [ "$response" = "Y" ]; then
            echo "Destroying database {{.DB_ID}}..."
            doctl databases delete {{.DB_ID}} --force
          else
            echo "Database preserved"
          fi
        fi
        
        echo "✓ Cleanup complete"
